---
layout: post
title: Lambdas - Know Your Closures
---

<p>Originally posted on: <a href='http://geekswithblogs.net/jolson/archive/2008/06/13/lambdas---know-your-closures.aspx'>http://geekswithblogs.net/jolson/archive/2008/06/13/lambdas---know-your-closures.aspx</a></p><p>In this post I want to discuss with you the importance of realizing how lambdas work (and why you should care). Let's dive right in with some code.</p> <p>Given the following code snippet, what would you expect the output to be (no cheating :P)?</p> <div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:cec767e2-c622-4acb-a46c-8f6813654c36" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">            var actions = new List&lt;Action&gt;();

            for (int i = 0; i &lt; 10; i++)
            {
                actions.Add(() =&gt; Console.WriteLine(i));
            }

            foreach (var action in actions)
            {
                action();
            }</pre></div>
<p>Would you believe me if I told you this is the output you get?</p>
<blockquote>
<p>10<br />10<br />10<br />10<br />10<br />10<br />10<br />10<br />10<br />10</p></blockquote>
<p>At first glance, one might expect this output:
</p><blockquote>
<p>0<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9</p></blockquote>
<p>But all tens are output instead. Why does this happen? Let's crank open Reflector and find out why...
</p><p>  </p><p>The first thing you'll notice is that the compiler has created a helper class to enable the closure we have. This helper class created by the compiler contains a local variable that we use to iterate over and a method that our delegate is contained within. This helper class is especially interesting because it is where the magic happens.
</p><p> </p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:4156c352-3da2-4815-967f-30f675084f8d" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">[CompilerGenerated]
private sealed class &lt;&gt;c__DisplayClass2
{
    // Fields
    public int i;

    // Methods
    public void &lt;Main&gt;b__0()
    {
        Console.WriteLine(this.i);
    }
}</pre></div>
<p>Rather than diving into MSIL, let's look at some pseudo-code of what the compiler _actually_ executes with the original code above (based on the generated MSIL):
</p><p> </p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:8049ab12-97de-46ec-980b-7fcc02790a65" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">var actions = new List&lt;Action&gt;();

&lt;&gt;c__DisplayClass2 localFrame = new &lt;&gt;c__DisplayClass2();
for (localFrame.i = 0; localFrame.i &lt; 10; localFrame.i++)
{
	actions.Add(localFrame.&lt;Main&gt;b__0);
}

foreach (var action in actions)
{
	action();
}</pre></div>
<p>  </p><p>Perhaps now you can see where the problem is. The "problem" in our original code exists because of the scope that our closures are defined. The local index from our for loop is now stored in our helper class &lt;&gt;c__DisplayClass2. And the code that is executed by the action is contained within the compiler generated &lt;Main&gt;b__0() method now. So the Console.WriteLine() method now uses the local variable from &lt;&gt;c__DisplayClass2 when it is executed. 
</p><p>  </p><p>So while we are looping through building all our actions, we are also incrementing the property i in localFrame (an instance of &lt;&gt;c__DisplayClass2). Then at the end when we are actually executing the actions, the &lt;Main&gt;b__0() is called and uses the local i property (which by this time, has already been incremented to 10 from our loop). And that's why every action we execute prints "10" instead of the 0 through 9 like we expected. 
</p><p>  </p><p>So, why do you need to know how these work? Take the following code that outputs items from an array of strings:
</p><p> </p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:e2582e7b-6872-4f60-a64b-2e82efe63b87" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">            var actions = new List&lt;Action&gt;();
            string[] urls = 
            { 
                "http://www.url.com", 
                "http://www.someurl.com", 
                "http://www.someotherurl.com", 
                "http://www.yetanotherurl.com" 
            };

            for (int i = 0; i &lt; urls.Length; i++)
            {
                actions.Add(() =&gt; Console.WriteLine(urls[i]));
            }

            foreach (var action in actions)
            {
                action();
            }</pre></div>
<p>  </p><p>This code looks pretty innocuous. Our bounds are protected, and we just index into our array to output a string. But, is that what we're really doing? Remember how closures work from above. The actual thing that happens when I run this code is this:
</p><p>  </p><p><a href="http://www.managed-world.com/images/LambdasKnowYourClosures_1288C/Confusing.jpg"><img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="445" alt="Confusing" src="http://www.managed-world.com/images/LambdasKnowYourClosures_1288C/Confusing_thumb.jpg" width="631" border="0" /></a> 
</p><p>  </p><p>Interesting. Even though our index variable should only even be less than the length of our url array, an exception is thrown because the index variable is actually equal to the length of our url array (and hence outside of the bounds thanks to 0-based indices). 
</p><p>  </p><p>Well, that wasn't what we were probably expecting. But now that we are having this "problem", what is the easiest way to resolve it? Remember that the problem is happening because of the scope of the variable within our closure. So to fix this, we can essentially declare a temporary variable that is unique in scope to this specific iteration through our array:
</p><p> </p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:6c15852c-ff10-43b3-bbb8-0ce8ba46fb67" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">            for (int i = 0; i &lt; urls.Length; i++)
            {
                string localUrl = urls[i];
                actions.Add(() =&gt; Console.WriteLine(localUrl));
            }</pre></div>
<p>  </p><p>And now the code is fixed. 
</p><p>  </p><p>Understanding how lambdas work is especially important when you start developing with a library that leverages lambdas heavily like LINQ does, or Parallel Extensions to the .NET Framework. And don't worry, even those people that know how lambdas work occasionally get bitten by this behavior. 
</p><p>  </p><p>Enjoy the coding, folks!</p> <img src="http://geekswithblogs.net/jolson/aggbug/126161.aspx" width="1" height="1" />
