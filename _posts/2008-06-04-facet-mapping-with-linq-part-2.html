---
layout: post
title: Facet Mapping with LINQ, Part 2
tags: [Programming]
---

<p>Originally posted on: <a href='http://geekswithblogs.net/jolson/archive/2008/06/03/facet-mapping-with-linq-part-2.aspx'>http://geekswithblogs.net/jolson/archive/2008/06/03/facet-mapping-with-linq-part-2.aspx</a></p><p>In "<a href="http://www.managed-world.com/2008/05/30/FacetMappingWithLINQPart1.aspx">Facet Mapping with LINQ, Part 1</a>", we discussed how to add Facet Mapping to your .NET application using an attribute-based solution. This solution just doesn't leave me very excited. As we recounted, there are some problems with using an attribute-based approach:</p> <ul> <li>Littering domain models with presentation layer-specific attributesÂ  </li><li>Doesn't support existing POCOs (that perhaps can't change)  </li><li>Can't support combinations of members (without create a new method property that actually does the combining (read: ugly)). </li></ul> <p>I personally only want one area of code to change if I alter my facet mapping. Having to change my POCOs when I want to change facet maps "smells" to me (and is itself a violation of the Single Responsibility Principle). Let's look at another way we can implement facet mapping in .NET via some more LINQ-goodness.</p> <p>In <a href="http://www.managed-world.com/2008/06/02/FluentLanguages.aspx">a previous post</a>, I talked about my new-found love for Fluent Languages in .NET (ala Moq or NInject). With attributes out of the way for facet mapping, I wanted to develop a library for facet mapping that was easy to use and could be used with existing code. Here are some of the "requirements" for the new facet mapping code (read: "requirements" means arbitrary features that I think are good and that I would like to see :P):</p> <ul> <li>Usable with an existing set of POCOs (without having to change a single line of code in those objects)</li> <li>Easily support combination of properties/methods or any arbitrary code that a person would want to create a facet on</li> <li>Readable and easy to use (read: my own reason to try to a fluent language interface :P)</li></ul> <p>Let's take a look at the proposed API (taken straight from my unit tests):</p> <div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:4acd200e-5361-4a53-ab96-73c7e830ae95" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">            // Given our list of cars
            List&lt;Car&gt; cars = new List&lt;Car&gt;() {
                new Car { Make = "Toyota", Model = "Corola", Price = 20000, Year = 2001 },
                new Car { Make = "Toyota", Model = "Corola", Price = 30000, Year = 2002 }
            };

            // Generate a facet map (list of Facets) that we can use
            var facets = FacetMap&lt;Car&gt;.Create()
                .AddFacetOn(c =&gt; c.Make)
                .AddFacetOn(c =&gt; c.Model)
                .GenerateFrom(cars)
                .ToList();
</pre></div>
<p>We can also define an arbitrary expression that we want to generate a facet on:</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:58b6fc79-e0b6-4ed9-a1f5-807b415a0f5c" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">            var facets = FacetMap&lt;Car&gt;.Create()
                .AddFacetOn("MakeAndModel", c =&gt; c.Make + " " + c.Model)
                .GenerateFrom(cars)
                .InParallel()
                .ToList();</pre></div>
<p>With FacetMap being a generic class, we can use it to generate facets on any existing CLR class we wish to. And with the use of lambda expressions to specify what we are creating facets on, our code can be refactored a bunch and not break our facet mapping. </p>
<p>Implementing FacetMap isn't actually all that difficult. Since all our operations can chain be chained together with each other, all of them actually return the same interface (our IFacetMap that the FacetMap class implements). </p>
<p>The first thing you notice is that we are creating a generic class so that our facet maps can be used with any POCO that exists out there (theoretically). And, we are hiding the constructor so that we can use a factory method (I happen to think it reads better, could just be my personal opinion though).</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:11ffedf6-8ef0-461b-bfb7-e5e5db3d1f2a" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">    public class FacetMap&lt;TResource&gt; : IFacetMap&lt;TResource&gt;
    {
        /// &lt;summary&gt;
        /// Constructor is hidden as we are using a factory method
        /// &lt;/summary&gt;
        private FacetMap() 
        {
            facetGenerators = new Dictionary&lt;string, Delegate&gt;();
        }

        /// &lt;summary&gt;
        /// Factory Method to create a new Facet Map
        /// &lt;/summary&gt;
        /// &lt;returns&gt;New FacetMap&lt;/returns&gt;
        public static IFacetMap&lt;TResource&gt; Create()
        {
            return new FacetMap&lt;TResource&gt;();
        }

        ...
    }</pre></div>
<p>Our class implemented our IFacetMap interface so that external code using our FacetMap is relying on abstractions outside of our Factory Method. And as you can see, all our methods return this interface so that we can chain all the methods together to form the fluent language shown above (the one exception being our Generate() method where we just return our list of Facets that were generated):</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:0a7d7960-40b7-45ee-85bb-89551eaac1e6" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">    public interface IFacetMap&lt;TResource&gt;
    {
        IFacetMap&lt;TResource&gt; AddFacetOn&lt;TResult&gt;(Expression&lt;Func&lt;TResource, TResult&gt;&gt; facetValue);
        IFacetMap&lt;TResource&gt; AddFacetOn&lt;TResult&gt;(string facetName, Expression&lt;Func&lt;TResource, TResult&gt;&gt; facetValue);
        IEnumerable&lt;Facet&lt;TResource&gt;&gt; GenerateFrom(IEnumerable&lt;TResource&gt; resources);
    }</pre></div>
<p>Why the "Expression&lt;Func&lt;X, Y&gt;&gt;" instead of just "Func&lt;X, Y&gt;". This is more a matter of convenience for the end-user. The end-user can write the code as if it was a normal Func&lt;X, Y&gt;, but we can do some fun things with the lambda expression like automatically generating the name of the facet based on the property or method the user passes in (notice that in the case of a more complex lambda expression, the user must specify the facet name since there is no way to generate a guaranteed user-friendly name for the lambda expression). </p>
<p>Internally, we are using a Dictionary&lt;string, Delegate&gt; to store all the passed in lambda expressions that are going to be used to generate our facets with. In the case where a facet name isn't explicitly stated, we automatically use the name of the Property or Method (depending on which type of expression was passed in):</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:0c0f2de5-e1c3-4544-88f0-f5e3db03d7a1" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#">        private Dictionary&lt;string, Delegate&gt; facetGenerators;

        public IFacetMap&lt;TResource&gt; AddFacetOn&lt;TResult&gt;(Expression&lt;Func&lt;TResource, TResult&gt;&gt; facetValue)
        {
            string facetName;
            if (facetValue.Body.NodeType == ExpressionType.MemberAccess)
            {
                MemberExpression expression = (MemberExpression)facetValue.Body;
                facetName = expression.Member.Name;
            }
            else if (facetValue.Body.NodeType == ExpressionType.Call)
            {
                MethodCallExpression expression = (MethodCallExpression)facetValue.Body;
                facetName = expression.Method.Name;
            }
            else
            {
                throw new InvalidHeadingExpressionException();
            }

            AddFacetOn(facetName, facetValue);
            return this;
        }

        public IFacetMap&lt;TResource&gt; AddFacetOn&lt;TResult&gt;(string facetName, Expression&lt;Func&lt;TResource, TResult&gt;&gt; facetValue)
        {
            if (!facetGenerators.ContainsKey(facetName))
            {
                facetGenerators.Add(facetName, facetValue.Compile());
            }
            else
            {
                throw new NonUniqueFacetAddedException();
            }

            return this;
        }</pre></div>
<p>The last thing we need to do is implement our Generate() method. Here, we are largely going to reuse the LINQ statement from our last post (<a href="http://www.managed-world.com/2008/05/30/FacetMappingWithLINQPart1.aspx">check it out</a>), the difference being that instead of pulling facets from properties decorated with our attribute we will use out internal dictionary that is built from our AddFacetOn methods.</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:8b63ba5e-296e-407c-8467-fc60ea78474d" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">        public IEnumerable&lt;Facet&lt;TResource&gt;&gt; GenerateFrom(IEnumerable&lt;TResource&gt; resources)
        {
            return from facet in facetGenerators
                   select new Facet&lt;TResource&gt;
                   {
                       Name = facet.Key,
                       Headings = (from resource in resources
                                   let value = facet.Value.DynamicInvoke(resource)
                                   orderby value
                                   group resource by value into g
                                   select new Heading&lt;TResource&gt;
                                   {
                                       Value = g.Key.ToString(),
                                       MatchCount = g.Count(),
                                       Filter = BuildFilter(facet.Value, g.Key.ToString())
                                   }).ToList()
                   };
        }

        private Func&lt;TResource, bool&gt; BuildFilter(Delegate facetValue, string headingValue)
        {
            return (resource) =&gt; facetValue.DynamicInvoke(resource).ToString() == headingValue;
        }</pre></div>
<p>And finally, that for every header we generate, we also generate a Filter (shown above). This Filter is of type Func&lt;TResource, bool&gt; so that it can be used in a Where() method to filter our existing list of resources at a later time based on the header that was chosen. </p>
<p>As you can see, there is some cool stuff you can do with LINQ around fluent languages very easily. And not only that, you can add some cool navigational techniques to your application using Facet Mapping that is quite easy to implement using the new features in LINQ.</p> <img src="http://geekswithblogs.net/jolson/aggbug/126164.aspx" width="1" height="1" />
