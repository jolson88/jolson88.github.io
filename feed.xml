<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://jolson88.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://jolson88.com/" rel="alternate" type="text/html" /><updated>2018-03-01T17:27:15-08:00</updated><id>http://jolson88.com/</id><title type="html">jolson88</title><subtitle>The home and blog of Jason Olson. Back-end systems developer by day,  husband/father-of-two/musician by night. Loves most things programming,  music, art, and science.</subtitle><entry><title type="html">Ignorance is not a four-letter word!</title><link href="http://jolson88.com/growth/2017/09/09/ignorance-not-four-letter-word.html" rel="alternate" type="text/html" title="Ignorance is not a four-letter word!" /><published>2017-09-09T00:00:00-07:00</published><updated>2017-09-09T00:00:00-07:00</updated><id>http://jolson88.com/growth/2017/09/09/ignorance-not-four-letter-word</id><content type="html" xml:base="http://jolson88.com/growth/2017/09/09/ignorance-not-four-letter-word.html">&lt;blockquote&gt;
  &lt;p&gt;Individuals who believe their talents can be developed (through hard work, good strategies, and input from others) have a growth mindset. They tend to achieve more than those with a more fixed mindset (those who believe their talents are innate gifts). This is because they worry less about looking smart and they put more energy into learning.&lt;/p&gt;

  &lt;p&gt;– Carol Dweck&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Why is to so hard to admit when we’re wrong? Why can we experience a sense of guilt when making mistakes? Why do we find it hard to admit to our peers that we don’t know something?&lt;/p&gt;

&lt;p&gt;I was originally exposed to the concept of a Growth Mindset when reading the book “Mindset: The New Psychology of Success” by Carol S. Dweck, Ph.D. It came recommended to me by a former manager of mine. I quickly recognized that I suffered from a Fixed Mindset and started to realize all the ways it impacted my life, especially my career as a software developer.&lt;/p&gt;

&lt;p&gt;Lately though, I’ve been thinking through this idea in more depth and I have come to the opinion that this behavior of “worshipping at the altar of Innate Talent” contributes to so many of the limiting behaviors we are facing in our software development culture today. These behaviors tend to give people very bad experiences and ultimately disrupt our ability to connect with each other in constructive and healthy ways.&lt;/p&gt;

&lt;h1 id=&quot;is-ignorance-bliss&quot;&gt;Is Ignorance Bliss?&lt;/h1&gt;

&lt;p&gt;There is a lot of peer pressure to look smart in this industry. We want the respect of our peers. We don’t want to admit we don’t know something and then look dumb in the process. Some communities even self-identify as “the smart kids” or others talk-down to “the more simple-minded folk.” This behavior only serves to perpetuate a fixed mindset.&lt;/p&gt;

&lt;p&gt;As an inventor, Edison made 1,000 unsuccessful attempts at inventing the light bulb. When a reporter asked, “How did it feel to fail 1,000 times?” Edison replied, “&lt;strong&gt;I didn’t fail 1,000 times. The light bulb was an invention with 1,000 steps.&lt;/strong&gt;” Henry Ford, R. H. Macy, and many other business pioneers failed many times before they succeeded. But somehow we’ve ended up with the belief that Mistakes Are Bad.&lt;/p&gt;

&lt;p&gt;We might feel compelled to cover up our mistakes. We may not want the people we respect and admire to see our mistakes. “What will people think?” “Maybe the company will realize I can’t actually do this job and they’ll finally fire me.” Why? We often view making mistakes as bad because we fail to realize that making mistakes is a great way to learn. We associate making mistakes with a lack of talent. Perhaps we think “if only I were smarter, I wouldn’t be making these mistakes.”&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I’ve failed over and over and over again in my life and that is why I succeed&lt;/p&gt;

  &lt;p&gt;– Michael Jordan&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thinking with a fixed mindset contributes to our insecurities having built-in defense mechanisms that serve to tear down others. It’s common in this industry to see people aggressively criticizing others or blaming others for mistakes. This is especially true the smaller or “sillier” the mistake is. Combine a silly mistake with a large negative impact and you will see plenty of finger pointing happening. It’s hard to admit that we can be one of the people pointing fingers.&lt;/p&gt;

&lt;p&gt;A problem though is that this behavior is self-defeating. Blaming others is ultimately a behavior that diminishes trust that others have in you. Avoiding taking responsibility for our own actions can also exhibit itself in a pattern of “half-truths, use spin, avoidance, and weasel words.”&lt;/p&gt;

&lt;p&gt;Remember, mistakes are not bad. Every mistake is an opportunity to learn and grow. By being honest when we make mistakes, we will start down a path of building trust with others.&lt;/p&gt;

&lt;h1 id=&quot;the-cult-of-personality&quot;&gt;The Cult of Personality&lt;/h1&gt;

&lt;p&gt;I fall victim to this… routinely. My personal development heroes are the Alan Kays, the Rich Hickeys, the Joe Armstrongs, the Erik Meijers, etc. I find myself thinking “I’ll never be as smart as them, if only I had as much talent and intellect as they do.” It’s not that they don’t offer huge swaths of knowledge you can learn from. It’s that I tend to tear myself down while admiring their knowledge. Our amount of talent is not fixed though. It will grow as we gain experience. There’s no need to be so self-critical.&lt;/p&gt;

&lt;p&gt;We can see the impact of Worshipping Talent exhibit itself in more insidious ways at technical conferences and in blog post comments too. It’s extremely easy to fall back on looking down at lesser-experienced developers sharing their own discoveries and lessons learned. Perhaps you’ve been sitting in the audience at a talk and silently wondered why &lt;em&gt;they&lt;/em&gt; are the ones giving a presentation? After all, “we want to hear from the folks that are smarter than us, that have more talent than us, the ones that we feel we can look up to”. You can even find presentations where attendees feel the need to correct the presenter or prove that they themselves know more.&lt;/p&gt;

&lt;p&gt;The belief in innate talent can also impact companies.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A company that plays the talent game makes it harder for people to practice growth-mindset thinking and behavior, such as sharing information, collaborating, innovating, seeking feedback, or admitting errors.&lt;/p&gt;

  &lt;p&gt;– Carol Dweck&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The seeking of innate talent in the job market is an area that I know I tend to fall back into a fixed mindset and need to improve. When I’m interviewing people or looking at the great team I work on, I think about how talented they are. I think about how smart they all are. And they most certainly are. But I’ve seen a lot of teams get burned by the seeking of developers with innate talent, talent they were just born with.&lt;/p&gt;

&lt;p&gt;Some companies look for the Rock Stars to hire, the people who have “freakish” amounts of talent. They get seduced by the talent. And what do companies frequently end up with? Prima donnas. People that lack empathy for others. People that are highly competitive and care more about their own accomplishments than the wake of damage they leave behind.&lt;/p&gt;

&lt;p&gt;Morale sinks. Paranoia grows. Teamwork wanes. Passion dies out. And the joy of the fun work we do in sotware is slowly but surely sucked out of the team.&lt;/p&gt;

&lt;p&gt;As I’ve progressed in my career, I’ve realized that I care most about working with people that are humble, trustworthy, and have integrity. Technology is easily learned. And technology changes frequently. Comparatively, it is much more difficult for a person to change the core of their personality and belief system.&lt;/p&gt;

&lt;h1 id=&quot;being-risk-averse&quot;&gt;Being Risk-Averse&lt;/h1&gt;

&lt;p&gt;When we are living in a culture dominated by a fixed mindset, there becomes a growing desire to look smart or to not be viewed as “dumb” as we discussed above. This impacts our career directly because we find ourselves censoring ourselves. We don’t share our experiences or lessons learned because we think others don’t care or that it won’t be useful to anybody else. After all, “What value could I possibly be providing that so many other people haven’t already provided?” We avoid the risk of being criticized, and we avoid the risk of failure.&lt;/p&gt;

&lt;p&gt;It doesn’t matter whether it’s blogging, whether it’s speaking at technical conferences, or sharing source code. It doesn’t matter if you just started programming yesterday, or if you’ve been programming for 20 years. Everybody can provide value. Be yourself and put yourself out there. Don’t worry about others. You are learning. And your own mistakes can help others learn too. And that’s A Great Thing. Don’t let perceived risks get in your way.&lt;/p&gt;

&lt;p&gt;Risk aversity crops up all the time in how companies behave as well.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Organizations that embody a growth mindset encourage appropriate risk-taking, knowing that some risks won’t work out. They reward employees for important and useful lessons learned, even if a project does not meet its original goals. They support collaboration across organizational boundaries rather than competition among employees or units.&lt;/p&gt;

  &lt;p&gt;– Carol Dweck&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It can be frustrating to work at a company that is risk-averse. Taking risks naturally involves the potential of something bad happening. When you overly focus on the potential for bad, you fail to recognize the learning that happens through risk taking, even when the bet doesn’t pan out.&lt;/p&gt;

&lt;p&gt;Similar to the risk of sharing our journey with the larger company, we can avoid sharing with our own team members as well. Being willing to admit you don’t know something is a form of risk tasking after all. But do we work at a company that actively encourages us to take these risks? Or do we suffer potential negative consequences from that action (e.g. fewer opportunities for growth due lack of perceived skill, team members having less confidence in our abilities after, lower performance reviews because we aren’t viewed as “strong/smart”, etc.)?&lt;/p&gt;

&lt;p&gt;Having a company culture that embraces a growth mindset is important. Making mistakes are a way we learn. That includes topics as scary as facing a major disruption or outage of a service. Companies with a fixed mindset view these occurences as horrendous, they are something that should be avoided at all costs. However, it is through these experiences that a company discovers the true ways their software can misbehave. It is through these lessons and growth that systems improve and evolve over time.&lt;/p&gt;

&lt;p&gt;The best way to make a more robust and reliable system is to be brave enough to find the ways the system breaks in the first place. Without this, systems remain stagnant and become more brittle over time as entropy sets in.&lt;/p&gt;

&lt;p&gt;But to prevent unwanted downtimes, or to avoid fixing the underlying problems due to the potential of risk, it is not uncommon for companies to introduce more process. Add extra steps, personal sign-offs, or some other mechanism that aims to prevent the same mistake from being possible at all costs. This is just a Band-Aid. The actual underlying flaw of the system is not being addressed. The company only aims to prevent the same flaw from being exposed in the future. AS these extra processes add up, the evolution of software slows down tremendously. It’s like building and maintaining a system with both hands tied behind your back.&lt;/p&gt;

&lt;h1 id=&quot;in-closing&quot;&gt;In Closing&lt;/h1&gt;
&lt;p&gt;So what can we do about all of this? First off, we need to be willing to take appropriate risks. We need to recognize that making mistakes provides opportunities to learn. We need to stop being hard on ourselves when we make mistakes. And we need to stop being hard on others when they make mistakes. Every mistake is a learning opportunity. You can not only learn from your own mistakes, but you can learn from others’ mistakes as well. Mistakes Are Good. They are a sign that you are stretching your abilities and growing.&lt;/p&gt;

&lt;p&gt;We need to be willing to share our journey with others. We need to not let fear get in the way. Sharing our journey and experiences will provide its own form of learning. By lurking in the shadows, forever on the sidelines of life, we are robbing ourselves of great experiences and slowing down the rate of growth we could otherwise experience. And we need to be supportive of others doing the same thing.&lt;/p&gt;

&lt;p&gt;We also need to stop defining our own self-worth by the set of knowledge we have today or how much innate talent we think we do or don’t have. By being willing to admit when we don’t know a topic, we are recognizing an area for learning. We need to acknowledge that every moment of not knowing can be a moment for learning. We can’t do this if we’re not willing to admit what we don’t know.&lt;/p&gt;

&lt;p&gt;We need to recognize that talent can be developed, that it comes from hard work and learning. We should not take away the avenues we have for making mistakes. We should not take away the avenues we have for learning from others. This will only inhibit growth in the long-run. We need to start living with a Growth Mindset and showing in actions what that means, both as individuals and as companies.&lt;/p&gt;</content><author><name></name></author><summary type="html">Individuals who believe their talents can be developed (through hard work, good strategies, and input from others) have a growth mindset. They tend to achieve more than those with a more fixed mindset (those who believe their talents are innate gifts). This is because they worry less about looking smart and they put more energy into learning. – Carol Dweck</summary></entry><entry><title type="html">It’s time for makefiles to make a comeback</title><link href="http://jolson88.com/programming/2017/09/04/time-for-makefiles-to-make-a-comeback.html" rel="alternate" type="text/html" title="It's time for makefiles to make a comeback" /><published>2017-09-04T00:00:00-07:00</published><updated>2017-09-04T00:00:00-07:00</updated><id>http://jolson88.com/programming/2017/09/04/time-for-makefiles-to-make-a-comeback</id><content type="html" xml:base="http://jolson88.com/programming/2017/09/04/time-for-makefiles-to-make-a-comeback.html">&lt;p&gt;Make and makefiles are lost in the past for many developers, its advantages lost in the stream of tools that are constantly reinventing the wheel of building software. It’s time we get off that crazy carousel.&lt;/p&gt;

&lt;p&gt;If you ask many developers the first thing that comes to mind with Make and makefiles, you will likely get several answers: C/C++, native projects, huge, archaic, or perhaps even old. Some younger developers that have grown up in the JavaScript ecosystem may not have even heard of Make and don’t realize the advantages they could harvest by using an existing, well-proven, and stable tool. Do we really need to be learning a new task runner or build system every 18 months as JavaScript frameworks come and go?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Those who do not understand Unix are condemned to reinvent it, poorly.&lt;/p&gt;

  &lt;p&gt;Usenet signature, November 1987
 — Henry Spencer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;what-does-this-have-to-do-with-modern-javascript-development&quot;&gt;What does this have to do with modern JavaScript development?&lt;/h1&gt;

&lt;p&gt;It’s not uncommon for larger JavaScript-based projects today to use a language that compiles down to JavaScript, either for powerful language features or for stronger type checking. We use Browserify to package all our JavaScript modules together into a bundle to allow front-end developers to have a more composition-based developer experience through modules (like back-end developers have in Node.js). We use LESS or SASS and compile out to CSS the browser can understand. We minimize our JavaScript to make the files smaller, resulting in faster downloads and page load times.&lt;/p&gt;

&lt;p&gt;What do all these things have in common with each other? At their core, they are each about taking a set of input files and transforming them into a set of output files. And this is exactly what Make is so incredibly good at.&lt;/p&gt;

&lt;p&gt;What do makefiles do? Makefiles are simply a declarative way to transform one file (or series of files) into another. That’s it, it’s that simple. It’s not specific to C, C++, or even to programming languages. You could just as easily use a makefile to transform markdown documentation into shipped HTML files, or to pack important files into a zip/tar archive, or do a myriad of other transformations.&lt;/p&gt;

&lt;p&gt;Thanks to its declarative nature and implementation, Make is able to use makefiles to only run the bare transforms needed to reach the final destination format. If a source file hasn’t changed since the last transformation, the source file doesn’t have to be processed again. In larger projects, this is a huge win to speed and a boon to the developer experience.&lt;/p&gt;

&lt;p&gt;Make first appeared over 40 years ago and a lot of software has been built with it since that time. It’s a battle-tested and stable piece of software that excels at exactly what it was meant to do: transforming files from a source format to a target format, with a very simple and easy-to-understand mechanism for declaring dependencies. It’s all text-based, doesn’t try to solve everything itself, and has a great integration experience through calling out to shell scripts. In other words, it is very Unix-like. This is hardly surprising given it’s birth within the Unix environment.&lt;/p&gt;

&lt;p&gt;Some developers have had experiences with very complicated and convoluted makefiles in larger projects. But it doesn’t need to be that way. In fact, it can be quite simple to build an NPM package that is implemented in Typescript (from building the source code to packaging the NPM package):&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PATH :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; node_modules/.bin:&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;

source_files    :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;wildcard lib/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.ts&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
build_files     :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;source_files:lib/%.ts&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;dist/%.js&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
PACKAGE         :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; build/my-package-1.0.0.tgz

.PHONY: all

all: &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;PACKAGE&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;build_files&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;source_files&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; package.json
    npm i
    tsc

&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;PACKAGE&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;build_files&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; .npmignore
    @mkdir &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
    @cd &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; npm pack &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Yes, the above example was for building a very small project. But just because the project becomes larger, doesn’t mean the user experience of Make diminishes. Let’s look at an example.&lt;/p&gt;

&lt;p&gt;At work, I’m currently working on a larger project that is based on AWS Kinesis and Lambda Functions, a stream-processing system architecture that is serverless. The “service” is based out of one git repository for convenience. But we want easily accessible shared libraries between our different Lambda handlers that can also be independently deployed projects. This makes deploying fixes or new functionality into production much quicker and with much less overhead than deploying the entire service as one large monolith.&lt;/p&gt;

&lt;p&gt;Our project structure is inspired by a post by StrongLoop on creating a modular Node.js project structure. Even though we are using TypeScript, this structure still definitely applies to us. So we started with the linking and npm scripts approach outlined in the blog post.&lt;/p&gt;

&lt;p&gt;Our project structure ended up looking like this in the abstract:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- src
    |- lib
        |- foo
            |- dist
                |- *.js (compiled JavaScript files)
            |- lib
                |- *.ts
            |- package.json
            |- makefile
        |- bar
            |- package.json
            |- makefile
        |- baz
            |- package.json
            |- makefile
    |- handlers
        |- alpha (depends on foo and bar)
            |- package.json
            |- makefile
        |- omega (depends on bar and baz)
            |- package.json
            |- makefile
- package.json
- makefile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But as the number of modules grew and the different ordering of dependencies started cropping up (as they do in larger Enterprise software), this approach quickly became unwieldy and painful. We found ourselves with a whole mix of preinstall, postinstall, and prestart scripts. It was very difficult to understand what was happening at build time to bootstrap the service. And integrating new sub-projects was a pain. It was also a “build everything or nothing” type of solution without us putting in a non-trivial amount of extra work.&lt;/p&gt;

&lt;p&gt;Before grabbing the latest build hotness like Gulp off the shelf, we decided to take a look at what Make could do for this since it’s an established tool and this is right up its alley. That decision is what kicked off my growing appreciation of Make (and inspired this blog post).&lt;/p&gt;

&lt;p&gt;Being a larger and growing project, we were naturally concerned about whether our build solution would scale. I happen to think that using Make, it most definitely does. And other than the Make quirks you get used to after you first use it for a while, I think that a junior developer could integrate their own libraries into this Make process.&lt;/p&gt;

&lt;p&gt;Here’s what a potential makefile for the above project would look like:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deps_install    :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/build/last-install-time
pkg_lib_foo     :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/build/foo-1.0.0.tgz
pkg_lib_bar     :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/build/bar-1.0.0.tgz
pkg_lib_baz     :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/build/baz-1.0.0.tgz
pkg_alpha       :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/build/alpha-1.0.0.tgz
pkg_omega       :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/build/omega-1.0.0.tgz

.PHONY: all handlers libs

all: libs handlers

handlers: &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;deps_install&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;MAKE&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; src/handlers/alpha
    &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;MAKE&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; src/handlers/omega

libs:
    &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;MAKE&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; src/lib/foo
    &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;MAKE&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; src/lib/bar
    &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;MAKE&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; src/lib/baz

&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;deps_install&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_foo&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_bar&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_baz&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
    @if &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_foo&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;findstring &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_foo&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/src/handlers/alpha &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; npm i &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_foo&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
    @if &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_bar&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;findstring &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_bar&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/src/handlers/alpha &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; npm i &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_bar&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/src/handlers/omega &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; npm i &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_bar&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
    @if &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_baz&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;findstring &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_baz&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/src/handlers/omega &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; npm i &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;pkg_lib_baz&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
    @touch &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;deps_install&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can see, it doesn’t need to be incredibly complicated. As this is a back-end service, we don’t have browserify, less, or minification. But it should help paint the picture that even with those additions, it should be pretty straightforward.&lt;/p&gt;

&lt;p&gt;If you make a change to the baz library, only baz is rebuilt and only baz is re-installed into the omega handler sub-project. Throw a watcher on this process (e.g. an npm script like watch ‘npm run build’ src — wait=5) and your build process becomes more rich and improves the local development experience.&lt;/p&gt;

&lt;h1 id=&quot;the-upsides&quot;&gt;The Upsides&lt;/h1&gt;

&lt;p&gt;One thing I really like about this is that things only run if they need to. You don’t even need an incremental compiler to make it possible. If source files haven’t been updated, there is no need to regenerate the target files. Make knows this by comparing the last modified times of the source files compared to the target files. You can see the easy integration into existing tools like tsc and npm. I didn’t need to wait until a wrapper was created (or to create my own wrapper) in a code-based build tool.&lt;/p&gt;

&lt;p&gt;Another less obvious benefit when comparing Make with code-based build tools like Grunt or Gulp is being declarative vs. imperative. You get to focus on the end result (declaring what needs to be done) instead of focusing on how the actual work is done.&lt;/p&gt;

&lt;p&gt;Make is also a standalone tool, so there is no need to bring in a bunch of other code dependencies like code-based task runners do. This not only makes the user experience better, but it also means there are fewer ways the software can break (e.g. a new version of a dependency that breaks functionality in the core tool).&lt;/p&gt;

&lt;h1 id=&quot;the-downsides&quot;&gt;The Downsides&lt;/h1&gt;

&lt;p&gt;Yes, it’s another tool and language that developers need to learn. But that’s what we get paid to do as developers, right? We always need to be learning new tools and techniques (or re-learning old tools and techniques in this case :P). We accept this forever-learning experience as the latest-and-greatest programming languages or software libraries roll out every month.&lt;/p&gt;

&lt;p&gt;But remember, in this case, we are learning a general tool that we will be to leverage in many different ways for a long time. Alton Brown need not worry, this tool is very much a multi-tasker. Make has been around for over 40 years and it’s not going anywhere anytime soon. Can we say the same about Grunt, Gulp, or the next Task Runner du jour?&lt;/p&gt;

&lt;p&gt;An accurate concern of using Make historically has been the lack of decent support on Windows. By leveraging Make, you were potentially making life more difficult for all your Windows users. That was a non-starter for many projects. But with the recent addition of Linux support in Windows and the ongoing change of heart under Satya Nadella’s leadership at Microsoft, this concern is hopefully a relic of the past. With all the great stuff to be learned from and used in Linux, I feel this trend is a major boon to software developers.&lt;/p&gt;

&lt;p&gt;Now is a great time to learn Make
So today is a great time to learn and start leveraging Make and makefiles. They are still very much relevant to our work today as developers. There’s no need for an ever-revolving door of task runners du jour. Don’t succumb to the build tool treadmill and burn yourself out. Learn a powerful tool you will be able to leverage for a long time and isn’t going anywhere any time soon.&lt;/p&gt;

&lt;p&gt;Yes, it’s time for Makefiles to make a comeback! Let’s do this!&lt;/p&gt;</content><author><name></name></author><summary type="html">Make and makefiles are lost in the past for many developers, its advantages lost in the stream of tools that are constantly reinventing the wheel of building software. It’s time we get off that crazy carousel.</summary></entry></feed>